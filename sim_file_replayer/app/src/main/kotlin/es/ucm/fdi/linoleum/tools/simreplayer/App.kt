/*
 * This source file was generated by the Gradle 'init' task
 */
package es.ucm.fdi.linoleum.tools.simreplayer

import io.opentelemetry.api.OpenTelemetry
import io.opentelemetry.sdk.autoconfigure.AutoConfiguredOpenTelemetrySdk
import io.opentelemetry.api.common.AttributeKey
import io.opentelemetry.context.Context
import io.opentelemetry.context.ContextKey
import io.opentelemetry.api.trace.Span
import io.opentelemetry.api.trace.SpanKind
import io.opentelemetry.api.trace.StatusCode
import io.opentelemetry.api.trace.Tracer
import io.opentelemetry.context.Scope

private const val SCOPE_NAME = "es.ucm.fdi.linoleum.tools.simreplayer"
private const val SCOPE_VERSION = "0.1.0"
private const val SCOPE_SCHEMA_URL = "https://demiourgoi.github.io"

/**
 * @return a suitable open telemetry API implementation, typically a configured
 * OTEL SDK instance
 * */
fun provideOtel(): OpenTelemetry {
    // https://opentelemetry.io/docs/languages/java/configuration/#zero-code-sdk-autoconfigure
    return AutoConfiguredOpenTelemetrySdk.initialize().openTelemetrySdk
}

fun provideTracer(otel: OpenTelemetry): Tracer {
    return otel.tracerProvider
        .tracerBuilder(SCOPE_NAME)
        .setInstrumentationVersion(SCOPE_VERSION)
        .setSchemaUrl(SCOPE_SCHEMA_URL)
        .build()
}

fun waitForSpanRecording(span: Span) {
    while (!span.isRecording) {
        println("waiting for span to get ready to record")
        Thread.sleep(500)
    }
    println("span ready to record!")
}

fun sendSomeArbitraryTraces(): Unit {
    val otel = provideOtel()
    val tracer = provideTracer(otel)

    val context = Context.current()
        .with(ContextKey.named<String>("fooCtxKey"), "barCtxKey")

    val span = tracer.spanBuilder("Hello-span")
        .setSpanKind(SpanKind.INTERNAL)
        .setAttribute(AttributeKey.stringKey("${SCOPE_NAME}.foo"),"bar")
        .setAttribute(AttributeKey.stringKey("${SCOPE_NAME}.qux"),"baz")
        .setParent(context)
        .startSpan()
    val ctxWithParentSpan = span.storeInContext(context)
    try {
        waitForSpanRecording(span)

        val childSpan = tracer.spanBuilder("child span")
            .setParent(ctxWithParentSpan)
            .startSpan()
        var childSpanScope: Scope? = null
        try {
            // only keeping this reference so we can close it later, and pop from the
            // stack in `Context.current()`
            childSpanScope = childSpan.makeCurrent()

            val grandSonSpan = tracer.spanBuilder("grandson")
                .setAttribute(AttributeKey.stringKey("${SCOPE_NAME}.grandSonFoo"), "bar")
                .startSpan()
            grandSonSpan.end()

        } finally {
            childSpanScope?.close()
            childSpan.end()
        }

        span.addEvent("foo event")
        span.setStatus(StatusCode.OK, "all good man")

    } finally {
        span.end()
        val spanCtx = span.spanContext
        println("Closed span with span id ${spanCtx.spanId}, trace id ${spanCtx.traceId}")
    }
}

fun main() {
    sendSomeArbitraryTraces()
    println("Bye")
}
