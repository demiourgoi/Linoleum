/*
 * This source file was generated by the Gradle 'init' task
 */
package es.ucm.fdi.linoleum.tools.simreplayer

import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json
import kotlinx.serialization.encodeToString

import java.util.logging.Logger
import java.nio.file.Path
import java.io.Closeable

import java.util.concurrent.Executors
import java.util.concurrent.ScheduledExecutorService
import java.util.concurrent.TimeUnit

import io.opentelemetry.api.OpenTelemetry
import io.opentelemetry.sdk.autoconfigure.AutoConfiguredOpenTelemetrySdk
import io.opentelemetry.api.common.AttributeKey
import io.opentelemetry.context.Context
import io.opentelemetry.context.ContextKey
import io.opentelemetry.api.trace.Span
import io.opentelemetry.api.trace.SpanKind
import io.opentelemetry.api.trace.StatusCode
import io.opentelemetry.api.trace.Tracer
import io.opentelemetry.context.Scope
import java.time.Duration

private const val SCOPE_NAME = "es.ucm.fdi.linoleum.tools.simreplayer"
private const val SCOPE_VERSION = "0.1.0"
private const val SCOPE_SCHEMA_URL = "https://demiourgoi.github.io"

/** A simulated trace span
 *
 * @property parentId Id of the span that is the parent of this span
 * @property startTimeOffsetNs How much time (in nanoseconds) to wait since the start of the replay to start this span. The parent
 * trace is created on its first span
 * @property durationNs How much much time (in nanoseconds) to wait since the span is created to close the span
 * */
@Serializable
data class SimSpan(
    val spanId: SpanId, val parentId: SpanId,
    val spanName: String, val spanKind: SpanKind=SpanKind.INTERNAL,
    val startTimeOffsetNs: Long,
    val durationNs: Long,
    val attributes: Map<String, String> = emptyMap()) {

    companion object {
        fun fromJsonStr(jsonStr: String): Result<SimSpan> =
            runCatching {  Json.decodeFromString<SimSpan>(jsonStr) }
    }

    fun toJsonStr(): String = Json.encodeToString(this)
}

/**
 * Id of a span in the simulation. These are arbitrary ids that won't be respected when emitting the trace
 * as the OTEL SDK will autogenerate new trace and span ids
 * A SimSpanId with an empty spanId is used for as the parentId of the first span of a trace.
 * */
@Serializable
data class SpanId(val traceId: String, val spanId: String? = null)

class SpanSimFilePlayer(
    private val scheduler: ScheduledExecutorService = DEFAULT_NEW_SCHEDULER(),
    private val logger: Logger = Logger.getLogger(SpanSimFilePlayer::class.java.name)
) : Closeable {

    companion object {
        // https://stackoverflow.com/questions/763579/how-many-threads-can-a-java-vm-support
        // https://stackoverflow.com/questions/7726871/maximum-number-of-threads-in-a-jvm
        private const val MAX_THREAD_POOL_SIZE_ENV_VAR = "MAX_THREAD_POOL_SIZE"
        private val MAX_THREAD_POOL_SIZE = (System.getenv(MAX_THREAD_POOL_SIZE_ENV_VAR) ?: "3000").toInt()
        private val SCHEDULER_TERMINATION_TIMEOUT = Duration.ofSeconds(10)
        private val DEFAULT_NEW_SCHEDULER = {
            Executors.newScheduledThreadPool(
                MAX_THREAD_POOL_SIZE
            ) { r: Runnable ->
                val thread = Thread(r)
                // so it doesn't block JVM shutdown
                // Java closes on Ctrl+C by default https://stackoverflow.com/questions/1611931/catching-ctrlc-in-java
                thread.isDaemon = true
                thread
            }
        }
    }
    /**
     * TODO assumptions
     * @return The list of actual span ids generated by OTEL, or an error instead
     * */
    fun playSim(path: Path): Result<List<SpanId>>{
        val lines = path.toFile().readLines()
        val spanResults = lines.map{SimSpan.fromJsonStr(it)}
        val parseFailures = spanResults.filter{it.isFailure}
        return when {
            parseFailures.isNotEmpty() -> parseFailures.first().map{listOf()}
            else -> playSim(spanResults.successes)
        }
    }

    /*
* TODO for reaply
* - order by time: be explicit about assumption of whether or not we allow spans to happen at the same millis
* - create trace on first span found; also handle wait for next span. Grouping by trace and short the spans in advance
*   might be useful. Consider using some kind of executor service for this
* - signal errors due to spans emitted late: log to mark this
* - Create unit test with an OTEL provider that does nothing: detect spans emitted late with a mock logger. Usa
* https://mockk.io/ for idiomatic mocking
* * Precondition: each SimSpanId is unique in a simulation file. spanName doesn't need to be
* * Precondition: each trace has a single root span that is a span with null parentId.spanId, that is also
* the span with lowest startTimeOffsetMillis
*
* */
    private fun playSim(spans: List<SimSpan>): Result<List<SpanId>>{
        // TODO reimplement with coroutines to avoid the limitation due to MAX_THREAD_POOL_SIZE
        val traces = spans
            .groupBy { it.spanId.traceId }
            // .toList()
            // .sortedBy { it.second. }


        return Result.success(listOf()) // FIXME
    }

    override fun close() {
        // Shutting down as recommended in https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html
        scheduler.shutdown()  // Disable new tasks from being submitted
        try {
            if (!scheduler.awaitTermination(
                    SCHEDULER_TERMINATION_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS)) {
                scheduler.shutdownNow() // Cancel currently executing tasks
                // Wait a while for tasks to respond to being cancelled
                if (!scheduler.awaitTermination(
                        SCHEDULER_TERMINATION_TIMEOUT.toMillis(), TimeUnit.MILLISECONDS)) {
                    logger.severe("Failure shutting down thread pool")
                }
            }
        } catch (ie: InterruptedException) {
            // (Re-)Cancel if current thread also interrupted
            scheduler.shutdownNow();
            // Preserve interrupt status
            Thread.currentThread().interrupt();
        }
    }
}

/** @return Filters and unwraps the successful results */
val <T> List<Result<T>>.successes: List<T>
    get() = this.flatMap {
        val value = it.getOrNull()
        when {
            value != null -> listOf(value)
            else -> listOf()
        }
    }

/**
 * @return a suitable open telemetry API implementation, typically a configured
 * OTEL SDK instance
 * */
fun provideOtel(): OpenTelemetry {
    // https://opentelemetry.io/docs/languages/java/configuration/#zero-code-sdk-autoconfigure
    return AutoConfiguredOpenTelemetrySdk.initialize().openTelemetrySdk
}

fun provideTracer(otel: OpenTelemetry): Tracer {
    return otel.tracerProvider
        .tracerBuilder(SCOPE_NAME)
        .setInstrumentationVersion(SCOPE_VERSION)
        .setSchemaUrl(SCOPE_SCHEMA_URL)
        .build()
}

// FIXME delete
fun waitForSpanRecording(span: Span) {
    while (!span.isRecording) {
        println("waiting for span to get ready to record")
        Thread.sleep(500)
    }
    println("span ready to record!")
}

// FIXME delete
fun sendSomeArbitraryTraces(): Unit {
    val otel = provideOtel()
    val tracer = provideTracer(otel)

    val context = Context.current()
        .with(ContextKey.named<String>("fooCtxKey"), "barCtxKey")

    val span = tracer.spanBuilder("Hello-span")
        .setSpanKind(SpanKind.INTERNAL)
        .setAttribute(AttributeKey.stringKey("${SCOPE_NAME}.foo"),"bar")
        .setAttribute(AttributeKey.stringKey("${SCOPE_NAME}.qux"),"baz")
        .setParent(context)
        .startSpan()
    val ctxWithParentSpan = span.storeInContext(context)
    try {
        waitForSpanRecording(span)

        val childSpan = tracer.spanBuilder("child span")
            .setParent(ctxWithParentSpan)
            .startSpan()
        var childSpanScope: Scope? = null
        try {
            // only keeping this reference so we can close it later, and pop from the
            // stack in `Context.current()`
            childSpanScope = childSpan.makeCurrent()

            val grandSonSpan = tracer.spanBuilder("grandson")
                .setAttribute(AttributeKey.stringKey("${SCOPE_NAME}.grandSonFoo"), "bar")
                .startSpan()
            grandSonSpan.end()

        } finally {
            childSpanScope?.close()
            childSpan.end()
        }

        span.addEvent("foo event")
        span.setStatus(StatusCode.OK, "all good man")

    } finally {
        span.end()
        val spanCtx = span.spanContext
        println("Closed span with span id ${spanCtx.spanId}, trace id ${spanCtx.traceId}")
    }
}

fun main() {
    sendSomeArbitraryTraces() // FIXME remove
    // TODO use https://kotlinlang.org/api/core/kotlin-stdlib/kotlin.io/use.html
    // for the replayer
    val replayer = SpanSimFilePlayer()
    println("Bye")
}
