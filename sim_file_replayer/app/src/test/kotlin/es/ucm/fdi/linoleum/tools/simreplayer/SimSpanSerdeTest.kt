/*
 * This source file was generated by the Gradle 'init' task
 */
package es.ucm.fdi.linoleum.tools.simreplayer

import io.kotest.core.spec.style.FunSpec
import io.kotest.datatest.withData
import io.kotest.matchers.collections.shouldHaveSize
import io.kotest.matchers.result.shouldBeFailure
import io.kotest.matchers.result.shouldBeSuccess
import io.kotest.matchers.string.shouldNotBeEmpty
import io.opentelemetry.api.trace.SpanKind
import kotlinx.serialization.SerializationException
import org.slf4j.LoggerFactory
import java.net.URI
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.Paths
import java.time.Duration

// If you mark a declaration as private, it will only be visible inside the file that contains the declaration.
// https://kotlinlang.org/docs/visibility-modifiers.html#packages
private fun simpleSimSpan() = SimSpan(
    spanId = SpanId(traceId = "traceId", spanId="spanId"),
    parentId = "parentSpanId",
    spanName="spanName",
    startTimeOffsetMs = 0, durationMs = 10, attributes = mapOf("foo" to "bar")
)

class SimSpanSerdeTest : FunSpec( {
    context("JSON SerDe tests") {
        withData(
            simpleSimSpan().copy(spanKind = SpanKind.CONSUMER),
            simpleSimSpan().copy(parentId = null)
        ) { simSpan ->
            val json = simSpan.toJsonStr()
            val deserializedSimSpanResult = SimSpan.fromJsonStr(json)
            deserializedSimSpanResult shouldBeSuccess simSpan
        }
    }

    test("Parsing a wrongly formatted string should fail") {
        val jsonStr = "not a SimSpan"
        SimSpan.fromJsonStr(jsonStr).shouldBeFailure<SerializationException>()
    }
})

fun getRootSimFilesPath(): Path {
    val buildRootDir = System.getenv(EnvVars.BUILD_DIR_VAR_NAME)
    val path =
        if (buildRootDir != null) {
            val simFilesPath = Path.of(buildRootDir).resolve("simFiles")
            Files.createDirectories(simFilesPath)
         simFilesPath
        } else {
            // Env vars defined in the Gradle build are not available in IntelliJ
            // so here we fall back to this path that also resolves to the build
            val rootResource = object{}.javaClass.getResource("/")
            Paths.get(rootResource?.toURI() ?: URI(""))
        }

    path.toString().shouldNotBeEmpty()
    return path
}

class CreateExampleSimFileTest : FunSpec({
    val logger = LoggerFactory.getLogger(CreateExampleSimFileTest::class.java.name)
    val simFilesPath by lazy {
        val path = getRootSimFilesPath()
        logger.info("Using simFilesPath: $path")
        path
    }

    fun testPlaySim(simFilePath: Path, spans: List<SimSpan>) {
        val otel = provideOtel()
        val tracer = provideTracer(otel)
        val replayer = SpanSimFilePlayer(tracer)
        val replayedSpans = replayer.playSim(simFilePath, Duration.ofSeconds(10))

        replayedSpans.shouldBeSuccess()
        replayedSpans.getOrNull()?.shouldHaveSize(spans.size)
    }

    test("Create an example sim file") {
        val simFilePath = simFilesPath.resolve("traces1.jsonl")
        logger.info("Writing to simFilePath: $simFilePath")

        val stepSizeMs = 1000L

        val traceId1 = "trace1"
        val root1 = SimSpan.new(
            traceId = traceId1, spanId = "root1",
            startTimeOffsetMs = 0, durationMs = stepSizeMs)
            .copy(attributes = mapOf("foo" to "bar"))
        val child11 = SimSpan.new(
            traceId = traceId1, spanId = "child11", parentSpan = root1,
            startTimeOffsetMs = 2 * stepSizeMs, durationMs = stepSizeMs * 3)
            .copy(attributes = mapOf("bar" to "baz"))
        val child111 = SimSpan.new(
            traceId = traceId1, spanId = "child111", parentSpan = child11,
            startTimeOffsetMs = (2.5 * stepSizeMs).toLong(), durationMs = stepSizeMs)
        val child12 = SimSpan(
            spanId = SpanId(traceId = traceId1, spanId="child12"),
            parentId = root1.spanId.spanId,
            spanName="child12",
            startTimeOffsetMs = 3 * stepSizeMs, durationMs = stepSizeMs
        )

        val traceId2 = "trace2"
        val root2 = SimSpan.new(
            traceId = traceId2, spanId = "root2",
            startTimeOffsetMs = (0.5 * stepSizeMs).toLong(), durationMs = 2 * stepSizeMs)
            .copy(attributes = mapOf("foo" to "bar"))

        val spans = listOf(root1, child11, child111, child12, root2)

        simFilePath.toFile().bufferedWriter().use{ out ->
            spans.forEach{ span ->
                out.write(span.toJsonStr())
                out.write(System.lineSeparator())
            }
        }
        logger.info("Done writing to trace1Path: $simFilePath")

        // Kotest doesn't have test dependencies https://github.com/kotest/kotest/issues/774
        testPlaySim(simFilePath, spans)
    }
})
