load file.maude

fmod MAYBE{X :: TRIV} is
 sort Maybe{X} .
 subsort X$Elt < Maybe{X} .
 op maybe : -> Maybe{X} [ctor] .
endfm

view Term from TRIV to META-TERM is
 sort Elt to Term .
endv

view Module from TRIV to META-MODULE is
 sort Elt to Module .
endv

fmod COMMANDS is

 sorts @Token@ @NeTokenList@ @Bubble@ @Command@ .

 op set`output`folder_. : @Token@ -> @Command@ [ctor] .
 op set`output`file_. : @Token@ -> @Command@ [ctor] .
 op set`solutions_. : @Token@ -> @Command@ [ctor] .
 op set`module_. : @Token@ -> @Command@ [ctor] .
 op quit : -> @Command@ [ctor] .
 op q : -> @Command@ [ctor] .
endfm

fmod META-LUEGO-SIGN is
  inc META-LEVEL .

  var  SSDS : SubsortDeclSet .
  vars IL IL' : ImportList .
  var  EqS : EquationSet .
  var  ODS : OpDeclSet .
  var  MAS : MembAxSet .
  var  RS : RuleSet .
  var  SS : SortSet .
  var  H : Header .

  op BUBBLES : -> FModule .
  eq BUBBLES
    = (fmod 'GRAMMAR is
        including 'QID-LIST .
        sorts none .
        none
        op 'token : 'Qid -> '@Token@
             [special(
               (id-hook('Bubble, '1 '1)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)))] .
        op 'neTokenList : 'QidList -> '@NeTokenList@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, '. ':)))] .
        op 'bubble : 'QidList -> '@Bubble@
             [special(
               (id-hook('Bubble, '1 '-1 '`( '`))
                op-hook('qidListSymbol, '__, 'QidList 'QidList, 'QidList)
                op-hook('qidSymbol, '<Qids>, nil, 'Qid)
                id-hook('Exclude, 'eq 'ceq 'rl 'crl 'mb 'cmb 'sd 'csd
                                  'var 'vars 'strat 'endm
                                  'endfm 'endsm 'sorts 'subsort 'subsorts
                                  'subclass 'subclasses 'op 'ops
                                  'protecting 'pr 'including 'inc 'extending
                                  'ctor 'assoc 'comm '==)))] .
        none
        none
     endfm) .

  op GRAMMAR : -> FModule [memo] .
  eq GRAMMAR = addImports((including 'COMMANDS .), BUBBLES) .

  op addImports : ImportList Module -> Module .
  eq addImports(IL', fmod H is IL sorts SS . SSDS ODS MAS EqS endfm) =
                     fmod H is IL IL' sorts SS . SSDS ODS MAS EqS endfm .
  eq addImports(IL', mod H is IL sorts SS . SSDS ODS MAS EqS RS endm) =
                     mod H is IL IL' sorts SS . SSDS ODS MAS EqS RS endm .
endfm

fmod COMMAND-PROCESSING is
 pr META-LEVEL .
 pr CONVERSION .

 vars TL TL' : TermList .
 var  Ct : Constant .
 var  S : String .
 var  T : Term .
 var  Q : Qid .
 var  N : Nat .

 op downQidList : Term ~> QidList .
 eq downQidList('nil.TypeList) = nil .
 eq downQidList(('__[TL], TL')) = (downQidList(TL) downQidList(TL')) .
 eq downQidList((Q, TL)) = (downQid(Q) downQidList(TL)) .
 eq downQidList(empty) = nil .

 op downQid : Term ~> Qid .
 eq downQid(Ct) = qid(substr(string(getName(Ct)), 1, length(string(getName(Ct))))) .

 op parseNum : Term ~> Nat .
 ceq parseNum(T) = N
  if Q := downQid(T) /\
     N := rat(string(Q), 10) .

 op parseString : Term ~> String .
 ceq parseString(T) = S
  if Q := downQid(T) /\
     S := string(Q) .
endfm

mod LUEGO-IO is
 pr COMMAND-PROCESSING .
 pr META-LUEGO-SIGN .
 pr MAYBE{Module} .
 pr MAYBE{Term} .
 inc STD-STREAM .
 pr LEXICAL .
 inc FILE .

 vars S OUTFILE OUTFILE' OUTFOLDER OUTFOLDER' : String .
 var  AtS : AttributeSet .
 var  MM : Maybe{Module} .
 var  M : Module .
 vars N N' : Nat .
 var  Ty : Type .
 var  T : Term .
 var  C : Char .
 var  O : Oid .
 var  Q : Qid .

 ***            ***
 *** Attributes ***
 ***            ***

 *** Output folder path
 op output-folder:_ : String -> Attribute [ctor] .
 *** Output file path
 op output-file:_ : String -> Attribute [ctor] .
 *** Parsed input
 op input:_ : Maybe{Term} -> Attribute [ctor] .
 *** Current state
 op state:_ : State -> Attribute [ctor] .
 *** Number of solutions
 op num-solutions:_ : Nat -> Attribute [ctor] .
 *** Current module
 op module:_ : Maybe{Module} -> Attribute [ctor] .

 ***            ***
 ***   States   ***
 ***            ***

 sort State .
 ops waiting processing write&wait write&end finished : -> State [ctor] .

 *** Messages ***

 op errorMsg : -> String .
 eq errorMsg = "\n" + printTokens('\! '\r) + "Error: " + printTokens('\o) .

 op noParseMsg : -> String .
 eq noParseMsg = errorMsg + "Command not parsed.\n\n" .

 op byeMsg : -> String .
 eq byeMsg = "\nBye!\n\n" .

 op setSolutionsMsg : Nat -> String .
 eq setSolutionsMsg(N) = "\nNumber of solutions set to " + printRed(string(N, 10)) + ".\n\n" .

 op noNatMsg : -> String .
 eq noNatMsg = errorMsg + "Natural number expected.\n\n" .

 op noStringMsg : -> String .
 eq noStringMsg = errorMsg + "String expected.\n\n" .

 op setFileMsg : String -> String .
 eq setFileMsg(OUTFILE) = "\nOutput file selected: " + printRed(OUTFILE) + ".\n\n" .

 op setFolderMsg : String -> String .
 eq setFolderMsg(OUTFILE) = "\nOutput folder selected: " + printRed(OUTFILE) + ".\n\n" .

 op printRed : String -> String .
 eq printRed(S) = printTokens('\! '\r) + S + printTokens('\o) .

 op errorModule : -> String .
 eq errorModule = errorMsg + "Module does not exist.\n\n" .

 op moduleMsg : Qid -> String .
 eq moduleMsg(Q) = "\nModule " + printRed(string(Q)) + " selected.\n\n" .

 ***           ***
 *** CID & OID ***
 ***           ***

 *** Object and class definition
 op luego : -> Oid [ctor] .
 op Luego : -> Cid [ctor] .

 **************************
 ***                    ***
 ***      Set module    ***
 ***                    ***
 **************************

 crl [set-module] :
     < luego : Luego | input: ('set`module_.['token[T]]), state: processing,
                       module: MM, AtS >
  => < luego : Luego | input: maybe, state: write&wait, module: M, AtS >
     write(stdout, luego, moduleMsg(Q))
  if Q := downQid(T) /\
     M := upModule(Q, true) .

 crl [set-module] :
     < luego : Luego | input: ('set`module_.['token[T]]), state: processing,
                       module: MM, AtS >
  => < luego : Luego | input: maybe, state: write&wait, module: MM, AtS >
     write(stdout, luego, errorModule)
  if Q := downQid(T) /\
     not (upModule(Q, true) :: Module) .

 *********************************
 ***                           ***
 ***      Set output folder    ***
 ***                           ***
 *********************************

 crl [set-output-folder] :
     < luego : Luego | input: ('set`output`folder_.['token[T]]), state: processing,
                       output-folder: OUTFOLDER, AtS >
  => < luego : Luego | input: maybe, state: write&wait, output-folder: OUTFOLDER', AtS >
     write(stdout, luego, setFolderMsg(OUTFOLDER'))
  if OUTFOLDER' := parseString(T) .

 *** TODO Add / at the end

 crl [set-output-folder-error] :
     < luego : Luego | input: ('set`output`folder_.['token[T]]), state: processing, AtS >
  => < luego : Luego | input: maybe, state: write&wait, AtS >
     write(stdout, luego, noStringMsg)
  if not (parseString(T) :: String) .

 *******************************
 ***                         ***
 ***      Set output file    ***
 ***                         ***
 *******************************

 crl [set-output-file] :
     < luego : Luego | input: ('set`output`file_.['token[T]]), state: processing,
                       output-file: OUTFILE, AtS >
  => < luego : Luego | input: maybe, state: write&wait, output-file: OUTFILE', AtS >
     write(stdout, luego, setFileMsg(OUTFILE'))
  if OUTFILE' := parseString(T) .

 crl [set-output-file-error] :
     < luego : Luego | input: ('set`output`file_.['token[T]]), state: processing, AtS >
  => < luego : Luego | input: maybe, state: write&wait, AtS >
     write(stdout, luego, noStringMsg)
  if not (parseString(T) :: String) .

 *****************************
 ***                       ***
 ***      Set solutions    ***
 ***                       ***
 *****************************

 crl [set-solutions] :
     < luego : Luego | input: ('set`solutions_.['token[T]]), state: processing,
                       num-solutions: N, AtS >
  => < luego : Luego | input: maybe, state: write&wait, num-solutions: N', AtS >
     write(stdout, luego, setSolutionsMsg(N'))
  if N' := parseNum(T) .

 crl [set-solutions-error] :
     < luego : Luego | input: ('set`solutions_.['token[T]]), state: processing, AtS >
  => < luego : Luego | input: maybe, state: write&wait, AtS >
     write(stdout, luego, noNatMsg)
  if not (parseNum(T) :: Nat) .

 ********************
 ***              ***
 ***      Quit    ***
 ***              ***
 ********************

 rl [parse-command] :
    < luego : Luego | input: 'quit.@Command@, state: processing, AtS >
 => < luego : Luego | input: maybe, state: write&end, AtS >
    write(stdout, luego, byeMsg) .

 rl [parse-command] :
    < luego : Luego | input: 'q.@Command@, state: processing, AtS >
 => < luego : Luego | input: maybe, state: write&end, AtS >
    write(stdout, luego, byeMsg) .

 ********************
 ***              ***
 ***     Parse    ***
 ***              ***
 ********************

 crl [parse-command] :
     gotLine(luego, stdin, S)
     < luego : Luego | input: maybe, state: waiting, AtS >
  => < luego : Luego | input: T, state: processing, AtS >
  if {T, Ty} := metaParse(GRAMMAR, tokenize(S), '@Command@) .

 crl [parse-command-error] :
     gotLine(luego, stdin, S)
     < luego : Luego | state: waiting, AtS >
  => < luego : Luego | state: write&wait, AtS >
     write(stdout, luego, noParseMsg)
  if not (metaParse(GRAMMAR, tokenize(S), '@Command@) :: ResultPair) .

 ********************
 ***              ***
 ***     Wrote    ***
 ***              ***
 ********************

 rl [remove-wrote] :
    wrote(luego, stdout)
    < luego : Luego | state: write&wait, AtS >
 => < luego : Luego | state: waiting, AtS >
    getLine(stdin, luego, "Luego> ") .

 rl [remove-wrote] :
    wrote(luego, stdout)
    < luego : Luego | state: write&end, AtS >
 => < luego : Luego | state: finished, AtS > .

 ************************************
 ***                              ***
 *** Initial value for attributes ***
 ***                              ***
 ************************************
 op initAtS : -> AttributeSet .
 eq initAtS = output-file: "", output-folder: "jsons/", input: maybe,
              state: waiting, num-solutions: 1, module: maybe .

 op run : -> Configuration .
 eq run
  = <> < luego : Luego | initAtS >
    getLine(stdin, luego, "Luego> ") .
endm

set print attribute on .
set print conceal on .
print conceal module:_ .

erew run .